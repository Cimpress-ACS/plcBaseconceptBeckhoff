<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.23">
  <POU Name="FB_Alm_Man" Id="{1df3d5ca-0fc7-41d6-8e17-a72131e17c96}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Alm_Man
VAR_INPUT
	;
END_VAR
VAR_IN_OUT
	bolCtrlRst: BOOL; // reset all controller
END_VAR

VAR CONSTANT
	/// config alarm handler number of elements of queue
	c_uinMaxAlmElements: UINT := 99;
	/// 0: with history on PLC, auto clr alarms from array if alarm state clear is set
	c_uinModeAlarm: UINT := 1;
	/// machine number 1, at the moment every time set to 1
	c_udiMachineNr: UDINT := 1;
	/// commands from the UI
	cCMD_RESET_ALL: INT := 2;
	/// reset state=RST, reset state CLR
	cCMD_RESET_RST: INT := 4;
	/// reset state CLR -> c_uinModeAlarm = 1, automatic reset will be done on PLC
	cCMD_RESET_CLR: INT := 6;
END_VAR
VAR
	///------------------------------------------------------------
	/// UI interface
	/// alarmarray PLC -> UI
	aAlm: ARRAY[0..c_uinMaxAlmElements] OF T_AlmElement;
	/// command interface for UI -> PLC
	intAlmCmd: INT;
	///------------------------------------------------------------
	/// real local variables
	fbGetLocalTime: NT_GetTime;
	strActTime: STRING;
	jj: UINT;
	EmptyAlmElement: T_AlmElement;
	intState: INT;
	intTestCtrl: INT := 12;
	intTestState: INT;
	udiTestAlarmNr: UDINT;
	dinTestInfo: DINT;
	aCtrlAlm: ARRAY[1..6] OF T_Ctrl_Alm;
	eActiveAlmClass: E_AlmClass;

	aCntActiveAlmPerClass: ARRAY[0..(E_AlmClass.Max_E_AlmClass-1)] OF UINT; // count off all active alarms per class, idx=0 all active alarms
	bolTimeReadDone : BOOL;
	bolTimeStampValid : BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
The alarm manager sets and clears alarms from the internal array. In the internal array all active 
alarms of a machine are listed. The list has no order. A new entry will be inserted at the next 
free place.

For the easy usage for UI the function block is to be define as global. And then the cmd for reset should be 
set when the button is pressed -> intAlmCmd = cCMD_RESET_ALL
All active alarms are shown in the aAlm array.

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		29.04.2013		AVME/KVO	Start history
0.00.2		06.01.2014		AVME/PRE	Implement the counted active messages array
0.00.3		17.02.2014		AVME/KVO	New Property IsInitDone 
										feedback at least one valid time stamp read out 
										-> check at startup before cyclic call of FB's to avoid alarms without valid timestamp
0.00.4		16.05.2014		AVME/DSC	-> Inserted new "setAlarm" Method from Patrik C. (code review)									
										-> BugFix, build sum of all active alarms
0.00.5		07.07.2014		AVME/KVO	-> BugFix Method setAlarm , clr and reset -> also possibel if one entry is zero possibel
___________________________________________________________________________________________________*)

// read out actual TIME
fbGetLocalTime.NETID := '';
fbGetLocalTime.START := NOT bolTimeReadDone;
fbGetLocalTime.TMOUT := T#5S;
fbGetLocalTime();

IF (fbGetLocalTime.START=TRUE) THEN
	IF  ((fbGetLocalTime.Busy=FALSE) AND (fbGetLocalTime.ERR=FALSE)) THEN
		bolTimeReadDone := TRUE;
		strActTime := TC2_UTILITIES.SYSTEMTIME_TO_STRING(fbGetLocalTime.TIMESTR); // YYYY-MM-DD-hh:mm:ss.xxx
		bolTimeStampValid := TRUE; // -> entry alarms with valid time stamp
	END_IF
ELSE
	bolTimeReadDone := FALSE;
END_IF


// interface for UI access
CASE intState OF
	
	0: // reset cmd
		intAlmCmd := cCMD_DONE; // Ready for new cmd
		intState := intState + 1;
		
	1: // wait for cmd
		IF (intAlmCmd=cCMD_RESET_ALL) OR (intAlmCmd=cCMD_RESET_CLR) OR  (intAlmCmd=cCMD_RESET_RST) THEN
			intState := intState + 1;
		END_IF
		
	2: // reset alarms
		// reset state=RST, reset state CLR
		THIS^.clearAlarm(((intAlmCmd=cCMD_RESET_ALL) OR (intAlmCmd=cCMD_RESET_RST)), TRUE);
		intState := intState + 1;
		
	3: // reset state machines
		bolCtrlRst := TRUE;
		intState := 0; // done

END_CASE

// build sum of all active alarms
aCntActiveAlmPerClass[0] := 0;
FOR jj:= 1 TO INT_TO_UINT(E_AlmClass.Max_E_AlmClass-1) BY 1 DO
	aCntActiveAlmPerClass[0] := aCntActiveAlmPerClass[0] + aCntActiveAlmPerClass[jj];
END_FOR

//**********************************************************************************************
// Test manual set/reset/clear alarm
//**********************************************************************************************
CASE intTestState OF
	
	0: // wait
		
	1: //CLR
		THIS^.setAlarm(intTestCtrl,udiTestAlarmNr,dinTestInfo,ADR(aCtrlAlm),E_AlmState.CLR,eActiveAlmClass);
		intTestState := 0;
		
	2: // RST
		THIS^.setAlarm(intTestCtrl,udiTestAlarmNr,dinTestInfo,ADR(aCtrlAlm),E_AlmState.RST,eActiveAlmClass);
		intTestState := 0;
		
	3: // SET
		THIS^.setAlarm(intTestCtrl,udiTestAlarmNr,dinTestInfo,ADR(aCtrlAlm),E_AlmState.SET,eActiveAlmClass);
		intTestState := 0;

END_CASE]]></ST>
    </Implementation>
    <Property Name="aCntPerClass" Id="{17110dc3-4d35-4a37-bd6b-2952ae96c5d5}">
      <Declaration><![CDATA[PROPERTY PUBLIC aCntPerClass : ARRAY[0..(E_AlmClass.Max_E_AlmClass-1)] OF UINT]]></Declaration>
      <Get Name="Get" Id="{4d684e1e-963f-4d13-bb51-77b23dd33a98}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[aCntPerClass := aCntActiveAlmPerClass;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="clearAlarm" Id="{4ba0e5bb-ff98-4060-ae97-9ef4f1f4d997}">
      <Declaration><![CDATA[METHOD clearAlarm : BOOL
VAR_INPUT
	///-> clear all entries with state RST
	bolClear_RST: BOOL;
	///-> clear all entries with state CLR
	bolClear_CLR: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR ii:= 0 TO INT_TO_UINT(E_AlmClass.Max_E_AlmClass-1) BY 1 DO
	aCntActiveAlmPerClass[ii] := 0; // reset alarm counter
END_FOR

FOR ii:= 0 TO c_uinMaxAlmElements BY 1 DO
	
	IF (aAlm[ii].udiNr>0) THEN 
		
		IF (((aAlm[ii].intState=E_AlmState.RST) AND (bolClear_RST)) OR
			((aAlm[ii].intState=E_AlmState.CLR) AND (bolClear_CLR)))THEN
			
			aAlm[ii] := EmptyAlmElement; // clear entry
		ELSE
			//count alarms per class
			aCntActiveAlmPerClass[aAlm[ii].eClass] := aCntActiveAlmPerClass[aAlm[ii].eClass] + 1; 
		END_IF
		
	END_IF
END_FOR

]]></ST>
      </Implementation>
    </Method>
    <Property Name="IsInitDone" Id="{7fbed69f-132f-46cd-9088-e949589753b9}">
      <Declaration><![CDATA[PROPERTY IsInitDone : BOOL]]></Declaration>
      <Get Name="Get" Id="{328f4b2e-2928-43b6-81f0-047d44205740}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[// feedback at least one valid time stamp read out 
//-> check at startup before cyclic call of FB's to avoid alarms without valid timestamp
IsInitDone := bolTimeStampValid;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="setAlarm" Id="{f5778ecc-b53c-477d-91b3-54a946399a18}">
      <Declaration><![CDATA[METHOD setAlarm : E_AlmClass
VAR_INPUT
	///from controller 
	intCtrlId: INT;
	///local alarm number
	udiAlarmNr: UDINT;
	///additional information - string???
	dinInfo: DINT;
	///corresponding alarm class
	p_Ctrl_Alm: POINTER TO T_Ctrl_Alm;
	///clear, resetable
	intState: E_AlmState;
END_VAR
VAR_IN_OUT
	eMe_ActivAlmClass: E_AlmClass;
END_VAR
VAR
	InAlmElement: T_AlmElement;
	ii: UINT;
	uinFirstEmptyIdx : UINT;
	e_LocAlmClass: E_AlmClass;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// chack if pointer valid
IF (p_Ctrl_Alm <> Tc3_MemMan.NULL) AND (udiAlarmNr>0) THEN 
	e_LocAlmClass := p_Ctrl_Alm[udiAlarmNr-1].eAlmClass;
ELSE
	// novalid pointer reached!!
   	e_LocAlmClass := E_AlmClass.EOFF; 
END_IF
 
// Copy alarm input data to local alm struct
InAlmElement.udiMachineNr := c_udiMachineNr;
InAlmElement.intCtrlId := intCtrlId;
InAlmElement.udiAlarmNr := udiAlarmNr;
InAlmElement.udiNr := 100000*InAlmElement.udiMachineNr + INT_TO_UDINT(100*InAlmElement.intCtrlId) + InAlmElement.udiAlarmNr;
InAlmElement.dinInfo := dinInfo;
InAlmElement.eClass := e_LocAlmClass;
InAlmElement.intState := intState;
InAlmElement.strDTEntry := strActTime;
InAlmElement.strText := p_Ctrl_Alm[udiAlarmNr-1].strText;

ii := 0;
uinFirstEmptyIdx := c_uinMaxAlmElements + 1;
//KVO 7.7.2014 AND (aAlm[ii].udiNr <> 0) removed from while because there could be entries above a cleared alarm!
WHILE (ii <= c_uinMaxAlmElements)  AND (InAlmElement.udiNr <> aAlm[ii].udiNr) DO
	IF (aAlm[ii].udiNr = 0) AND (uinFirstEmptyIdx>c_uinMaxAlmElements) THEN // entry first empty index
		uinFirstEmptyIdx := ii;
	END_IF
	ii := ii + 1;              
END_WHILE

// set ii to first empty place (new entry) in array if entry not allready exists in array
IF (uinFirstEmptyIdx<= c_uinMaxAlmElements) AND (InAlmElement.udiNr <> aAlm[ii].udiNr) THEN
	ii := uinFirstEmptyIdx;
END_IF

IF (ii <= c_uinMaxAlmElements) THEN
	
	// Alarm already exist
	IF (aAlm[ii].udiNr = InAlmElement.udiNr) THEN
		CASE InAlmElement.intState OF
			E_AlmState.SET, E_AlmState.RST:
				// refresh state, alarm additional info
				aAlm[ii].dinInfo := InAlmElement.dinInfo;
				aAlm[ii].intState := InAlmElement.intState;
			E_AlmState.CLR:
				IF (aCntActiveAlmPerClass[aAlm[ii].eClass]>0) THEN
					aCntActiveAlmPerClass[aAlm[ii].eClass] := aCntActiveAlmPerClass[aAlm[ii].eClass] - 1; 
				END_IF
				
				IF (c_uinModeAlarm=1) THEN // no history on PLC
					aAlm[ii] := EmptyAlmElement; // clear entry
				ELSE
					aAlm[ii].intState := E_AlmState.CLR; // set clear state -> entry in plc history if needed
				END_IF
		END_CASE          
	END_IF
	
	// New Alarm entry
	IF (aAlm[ii].udiNr = 0) THEN
		CASE InAlmElement.intState OF
			E_AlmState.SET, E_AlmState.RST:
				aAlm[ii] := InAlmElement;
				//count alarms per class
				aCntActiveAlmPerClass[aAlm[ii].eClass] := aCntActiveAlmPerClass[aAlm[ii].eClass] + 1; 
	
				IF (InAlmElement.eClass>eMe_ActivAlmClass) THEN 
					eMe_ActivAlmClass := InAlmElement.eClass;
				END_IF
		END_CASE
	END_IF
	
END_IF]]></ST>
      </Implementation>
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>