<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.18">
  <POU Name="FB_CtrlBase" Id="{b1ac081d-d4f6-4134-a9f2-1facb44ddfd2}">
    <Declaration><![CDATA[{attribute 'reflection' := ''}
FUNCTION_BLOCK FB_CtrlBase IMPLEMENTS I_CtrlBase
VAR
	///Commen interface struct for public access
	CIf: T_Ctrl_CIf;
	///basic local controller class struct
	me: T_Ctrl_Class;
	fbSimulationTimer: TON;
	{attribute 'noinit' := ''}
	{attribute 'instance-path' := ''}
	strMyInstancePath: STRING;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Basic controller implementation. This Controller should be the base father controller for all in the
feature implemented ctontroller classes.


History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		25.04.2013		AVME/KVO	Start history


___________________________________________________________________________________________________*)


IF (me.bolActivate) THEN // cyclic call enabled
	
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();
	
		Always();
		
		StateMachine();
		
		CycleEndDuty();
	END_IF
	
END_IF;]]></ST>
    </Implementation>
    <Method Name="iniCtrlArray" Id="{e98d4d72-bc58-4859-aacb-6f877c5e7b6b}">
      <Declaration><![CDATA[METHOD iniCtrlArray : BOOL
VAR_INPUT
	p_pCtrlArray: POINTER TO POINTER TO FB_CtrlBase;
	intCtrlID: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[iniCtrlArray := FALSE;

IF (TRUE) THEN//e_CtrlID <= E_CtrlId.E_CtrlIdMax) THEN
	p_pCtrlArray[intCtrlID] := THIS;
	THIS^.CIf.Info.intCtrlID := intCtrlID;
	iniCtrlArray := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{8e2e4733-0365-496f-ab15-4b7cede62253}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// enable cyclic call
me.bolActivate := TRUE;
// reset init flag
CIf.Info.bolInitDone := FALSE;

//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
CIf.Job.aCmdList[0].intCmd := cCMD_PON;
CIf.Job.aCmdList[0].strName := 'Power On';
CIf.Job.aCmdList[0].bolAvailable := TRUE;

CIf.Job.aCmdList[1].intCmd := cCMD_OFF; // for test simulation single answer
CIf.Job.aCmdList[1].strName := 'Off';
CIf.Job.aCmdList[1].bolAvailable := TRUE;

// set name of class/typ
CIf.Info.strType := 'FB_CtrlBase'; 

// for tests
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := TRUE;

//------------------------------------------------------------------------------------------------------------------------
CIf.Info.strName := getStrInstanceName(strMyInstancePath); // get name of instance]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{bd82cc15-d8ac-4107-8c15-5f9179fe156e}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// main statemachine of base controller
CASE me.StateMachine.intState OF
    cSTA_PONBusy: 
        THIS^.sta_PONBusy();
    cSTA_PON: 
        THIS^.sta_PON();
	cSTA_OFFBusy: 
        THIS^.sta_OFFBusy();
    cSTA_OFF: 
        THIS^.sta_OFF();
    cSTA_ERROR: 
        THIS^.sta_ERROR();
    cSTA_ERRORQuit: 
        THIS^.sta_ERRORQuit();
    cSTA_SINGLE_ANSWER: 
        THIS^.sta_SINGLE_ANSWER();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PONBusy" Id="{b0f25ef0-7497-4069-a2fe-4d79633781d2}">
      <Declaration><![CDATA[METHOD PROTECTED sta_PONBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (FALSE) THEN
			;
		ELSIF (TRUE) THEN
			me.StateMachine.intStateNext := cSTA_PON;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PON" Id="{a5415b1f-2cd7-4edc-ac8d-d843adc525dc}">
      <Declaration><![CDATA[METHOD PROTECTED sta_PON : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (FALSE) THEN
			;
		ELSIF (me.intCmd=cCMD_OFF) THEN
			me.StateMachine.intStateNext := cSTA_OFFBusy;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERROR" Id="{d85375e1-5676-4086-9d3e-5d9b445cb21a}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERROR : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERRORQuit" Id="{723cb042-1b57-4b76-b123-9f9bd89cfe75}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERRORQuit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		// evtl. wait time if reset of device is necessary and then decide to go to states or ERROR state
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // reset feedback channel for parent
			CIf.Job.bolAlmReset := FALSE;
		END_IF
		
		// State Change Condition
		IF (CIf.Job.bolAlmReset = FALSE) OR (me.StateMachine.intStateHistory<=cSTA_PON) THEN
			me.StateMachine.intStateNext := cSTA_PONBusy;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_SINGLE_ANSWER" Id="{20d9321e-714d-47e4-806b-d308b0dda850}">
      <Declaration><![CDATA[METHOD PROTECTED sta_SINGLE_ANSWER : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation of SINGLE_ANSWER
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		IF ((me.intCmd<>cCMD_INITIALIZED) AND (me.intCmd<>cCMD_DONE)) THEN
			IF (THIS^.CheckCmdValid()=TRUE) THEN
				IF (me.intCmd<>me.intCmdLast) THEN
					me.StateMachine.udiTimeInState_ms := 0;  // reset timer
				END_IF
				IF (me.StateMachine.udiTimeInState_ms >= me.StateMachine.udiStateSimSetTime_ms) THEN
					CIf.Job.intState := me.intCmd; // simulate final state
				ELSE
					CIf.Job.intState := me.intCmd-1; // simulate busy state
				END_IF
			END_IF
		END_IF
		
		// State Change Condition
		IF (FALSE) THEN
			;
		ELSIF (CIf.SwCfg.bolExist=TRUE) THEN
			me.StateMachine.intStateNext := cSTA_PONBusy;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CycleStartDuty" Id="{b39f7fe6-b47d-4271-b1d4-ddb49a6de37a}">
      <Declaration><![CDATA[METHOD PROTECTED CycleStartDuty : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
	// --------------------------------------------------------------------------
	// input bridge
	// --------------------------------------------------------------------------
	THIS^.IoInBridge(); // digitale and analoge inputs read from hardware or forcing

	// --------------------------------------------------------------------------
	// check alarm recation class of master													
	// --------------------------------------------------------------------------
	THIS^.CheckParentAlmClass();
	
	// ----------------------------------------------------------------------------------
	// check the highest active alarm -> set local class
	// ----------------------------------------------------------------------------------
	IF (me.Alarm.eParent_ActivAlmClass>CIf.job.eMe_ActivAlmClass) THEN
		me.Alarm.eActivAlmClass := me.Alarm.eParent_ActivAlmClass;
	ELSE
		me.Alarm.eActivAlmClass := CIf.job.eMe_ActivAlmClass;
	END_IF
	
	// --------------------------------------------------------------------------
	// get command											
	// --------------------------------------------------------------------------
	IF (CIf.Job.eMode = E_Mode.MANU) THEN
		me.intCmd := CIf.Job.intMCmd;  
	ELSE
		IF (me.eModeHistory <> E_MODE.AUTO) THEN
			CIf.Job.intMCmd:= cCMD_DONE;	// reset manual command
			me.bolChangeBackToAUTO := TRUE;	// switch off  or .....
		END_IF
		CIf.Job.eMode := E_MODE.AUTO;
		me.intCmd := CIf.Job.intACmd;
	END_IF
	CIf.Job.strCmd := THIS^.getCmdState(intCmdState:=me.intCmd,bolState:=FALSE);
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="CycleEndDuty" Id="{57f49fa2-4066-4912-99d4-5d1d7e5e0228}">
      <Declaration><![CDATA[METHOD PROTECTED CycleEndDuty : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
me.eModeHistory := CIf.Job.eMode;				// save mode to detect mode switches
me.intCmdLast := me.intCmd;
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN // only if no simulation is active
	CIf.Job.intState := me.StateMachine.intState;		// set information of actual state to controller interface
	CIf.Job.strState := THIS^.getCmdState(intCmdState:=CIf.Job.intState,bolState:=TRUE);
ELSE
	CIf.Job.strState :=  TC2_STANDARD.CONCAT(STR1:='SINGLE_ANSWER-',STR2:=THIS^.getCmdState(intCmdState:=CIf.Job.intState,bolState:=TRUE));
END_IF

	
IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	me.StateMachine.intState := me.StateMachine.intStateNext;  // set next state for next cycle
	me.StateMachine.udiTimeInState_ms := 0; // reset timer
	// log state change -> open point
ELSE
	// increment time in state	
	me.StateMachine.udiTimeInState_ms := me.StateMachine.udiTimeInState_ms + me.FUBInfo.udiSample_ms;
END_IF

// --------------------------------------------------------------------------
// Final state reached -> reset command
// --------------------------------------------------------------------------
IF (CIf.Job.intState=me.intCmd) THEN 
	CIf.Job.intACmd := cCMD_DONE;
	CIf.Job.intMCmd := cCMD_DONE;
END_IF

// --------------------------------------------------------------------------
// reset local alarm class
// --------------------------------------------------------------------------
IF (CIf.Job.bolAlmReset=TRUE) AND (CIf.Job.intState<>cSTA_ERROR) AND (CIf.Job.intState<>cSTA_ERRORQuit) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE;
	CIf.Job.bolAlmReset := FALSE;
END_IF

// --------------------------------------------------------------------------
// output bridge
// --------------------------------------------------------------------------
THIS^.IoOutBridge();	// digitale and analoge outputs or forcing write to hardware
]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoInBridge" Id="{595969fe-b7bc-45d2-a690-6bba2ee66204}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	//KVO??? alternative only without feedback getIn(ctrl.ifc.Job.bol_Force ,ADR(ctrl.In.bol_PosSwitchBasicDefTyp);
	//ctrl.In.bol_PosSwitchBasicDefTyp.intern := getIn(ctrl.ifc.Job.bol_Force ,ADR(ctrl.In.bol_PosSwitchBasicDefTyp);
ELSE
	//simulation of global IO
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckParentAlmClass" Id="{ec1be44d-8050-49b4-a7d6-f8a2a0151732}">
      <Declaration><![CDATA[METHOD PRIVATE CheckParentAlmClass : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// --------------------------------------------------------------------------
// check alarm recation class of master													
// --------------------------------------------------------------------------
IF (CIf.Job.eParent_ActivAlmClass = E_AlmClass.EOFF) THEN
	me.Alarm.eParent_ActivAlmClass := E_AlmClass.EOFF;
	// prevent automatic restart in manual or automatic
	CIf.job.intACmd := cCMD_DONE;
	CIf.job.intMCmd  := cCMD_DONE;
ELSE
	me.Alarm.eParent_ActivAlmClass := E_AlmClass.NONE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{d773bf4e-1480-43c6-b1d9-815b7b2800b0}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	; // always error supervision
	
END_IF

// ----------------------------------------------------------------------------------
// Conditions Always
IF (me.bolChangeBackToAUTO=TRUE) THEN // switch mode to automatic switch off controller
	me.StateMachine.intStateNext := cSTA_OFFBusy;
	me.bolChangeBackToAUTO := FALSE;
END_IF

IF ((me.StateMachine.intState=cSTA_INITIALIZED) OR (me.intCmd=cCMD_PON)) AND (me.StateMachine.intState<>cSTA_PONBusy)  AND (me.StateMachine.intState<>cSTA_PON) THEN // switch after startup to PONBusy
	me.StateMachine.intStateNext := cSTA_PONBusy;
END_IF

IF (CIf.SwCfg.bolExist=FALSE) AND (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN // hardware of controller does not exist
	me.StateMachine.intStateNext := cSTA_SINGLE_ANSWER;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CheckCmdValid" Id="{b8086996-e332-408f-922c-a6fe1cc399cf}">
      <Declaration><![CDATA[METHOD PRIVATE CheckCmdValid : BOOL
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CheckCmdValid := FALSE;
FOR ii:=0 TO cMaxCmdPerCtrl BY 1 DO
	// check if a valid cmd
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) OR (CIf.Job.aCmdList[ii].intCmd=cCMD_DONE) THEN
		EXIT; // end for
	END_IF
	// check if a in this ctrl implemented cmd
	IF (CIf.Job.aCmdList[ii].intCmd=me.intCmd) THEN
		CheckCmdValid := TRUE;
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoOutBridge" Id="{87aaeab6-874a-431a-9966-ce76def3ae9b}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN


//KVO??? alternative only without feedback getIn(ctrl.ifc.Job.bol_Force ,ADR(ctrl.In.bol_PosSwitchBasicDefTyp);
	// check interlocks to prevent damages
	//IF (SIf.Ilk.bolOverwrite=FALSE) THEN
		//IF (SIf.Ilk.bolOut=FALSE) THEN
			//ctrl.Out.bolOut.map := setOut(ctrl.ifc.Job.bol_Force ,ADR(ctrl.Out.bolOut);
		//ELSE
			// switch off???
			// error??
		//END_IF
	//end_if

	//THIS^.Out_bolOut := SIf.Out.bolOut.map;

END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlCIf" Id="{f5175047-6b1c-409e-9131-8b8198d7f33b}">
      <Declaration><![CDATA[METHOD getCtrlCIf : POINTER TO T_Ctrl_CIf
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlCIf := adr(THIS^.CIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{82ace724-adec-4b08-9e9f-389661fc0c1a}">
      <Declaration><![CDATA[METHOD PROTECTED CtrlInit : BOOL
VAR
	udiTaskCnt: UDINT;
	fbGETCURTASKINDEX: Tc2_System.GETCURTASKINDEX;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//automatic read out infos about FUB
udiTaskCnt := TwinCAT_SystemInfoVarList._AppInfo.TaskCnt;
fbGETCURTASKINDEX();
udiTaskCnt := fbGETCURTASKINDEX.index;
me.FUBInfo.udiSample_ms := TwinCAT_SystemInfoVarList._TaskInfo[UDINT_TO_DINT(udiTaskCnt)].CycleTime/10000; //[ms] X[100ns]/10000 -> [ms]]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{a5e84ddc-52c5-4dca-8f24-77b6da9322fb}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// get string cmd/state string information in runtime
IF (bolState=FALSE) THEN
	// cmd's
	CASE intCmdState OF
		cCMD_DONE: 
			getCmdState := 'cCMD_DONE';
		cCMD_INITIALIZED: 
			getCmdState := 'cCMD_INITIALIZED';
		cCMD_PON: 
			getCmdState := 'cCMD_PON';
		cCMD_EOFF: 
			getCmdState := 'cCMD_EOFF';
		cCMD_OFF: 
			getCmdState := 'cCMD_OFF';
		cCMD_INIT: 
			getCmdState := 'cCMD_INIT';
		cCMD_RUN: 
			getCmdState := 'cCMD_RUN';
		cCMD_STOP: 
			getCmdState := 'cCMD_STOP';
		cCMD_TSTOP: 
			getCmdState := 'cCMD_TSTOP';
	END_CASE;
ELSE

// cmd's
	CASE intCmdState OF
		cSTA_DONE: 
			getCmdState := 'cSTA_DONE';
		cSTA_INITIALIZED: 
			getCmdState := 'cSTA_INITIALIZED';
		cSTA_PONBusy: 
			getCmdState := 'cSTA_PONBusy';
		cSTA_PON: 
			getCmdState := 'cSTA_PON';
		cSTA_EOFFBusy: 
			getCmdState := 'cSTA_EOFFBusy';
		cSTA_EOFF: 
			getCmdState := 'cSTA_EOFF';
		cSTA_OFFBusy: 
			getCmdState := 'cSTA_OFFBusy';
		cSTA_OFF: 
			getCmdState := 'cSTA_OFF';
		cSTA_INITBusy: 
			getCmdState := 'cSTA_INITBusy';
		cSTA_INIT: 
			getCmdState := 'cSTA_INIT';
		cSTA_RUNBusy: 
			getCmdState := 'cSTA_RUNBusy';
		cSTA_RUN: 
			getCmdState := 'cSTA_RUN';
		cSTA_STOPBusy: 
			getCmdState := 'cSTA_STOPBusy';
		cSTA_STOP: 
			getCmdState := 'cSTA_STOP';
		cSTA_TSTOPBusy: 
			getCmdState := 'cSTA_TSTOPBusy';
		cSTA_TSTOP: 
			getCmdState := 'cSTA_TSTOP';
			
		cSTA_ERROR: 
			getCmdState := 'cSTA_ERROR';
		cSTA_ERRORQuit: 
			getCmdState := 'cSTA_ERRORQuit';
		cSTA_SINGLE_ANSWER: 
			getCmdState := 'cSTA_SINGLE_ANSWER';
	END_CASE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{fb45899b-0d32-4910-9443-acd40fb2d0aa}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (FALSE) THEN
			;
		ELSIF (TRUE) THEN
			;	//me.StateMachine.intStateNext := cSTA_PON;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{b43c45d6-db5e-43b9-b8e6-886e382de8a7}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (FALSE) THEN
			;
		ELSIF (TRUE) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>